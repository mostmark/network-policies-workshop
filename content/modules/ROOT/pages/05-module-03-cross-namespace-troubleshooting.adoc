= Module 3: Cross-namespace policies and troubleshooting
:source-highlighter: rouge
:toc: macro
:toclevels: 1

ACME Corporation's platform team has expanded the proof-of-concept. "We have multiple teams deploying to different namespaces," the platform lead explains. "The frontend team's applications need to reach the backend team's APIs across namespaces, but nothing else. And when something breaks, we need a systematic way to diagnose network policy issues."

In this module, you'll implement cross-namespace network policies and learn a structured approach to troubleshooting connectivity problems in a multi-namespace environment.

== Learning objectives

By the end of this module, you'll be able to:

* Create network policies that allow traffic between specific namespaces
* Use namespace labels to build scalable cross-namespace rules
* Apply a systematic troubleshooting methodology for network policy issues
* Use diagnostic commands to identify which policies are blocking traffic

[#exercise-1-implement-cross-namespace-policies]
== Exercise 1: Implement cross-namespace policies

ACME's backend team deploys APIs in a dedicated namespace. The frontend team, working in a separate namespace, needs to reach those APIs. You'll set up this multi-namespace scenario and create policies that allow only the required cross-namespace traffic.

=== Set up the multi-namespace environment

. Create a namespace for the backend team:
+
[source,bash,role=execute]
----
oc new-project backend-team
----

. Deploy a backend API application:
+
[source,bash,role=execute]
----
oc new-app --name backend-api --image quay.io/redhattraining/hello-world-nginx:v1.0
----

. Wait for the backend pod to be ready:
+
[source,bash,role=execute]
----
oc rollout status deployment/backend-api --timeout=60s
----

. Apply a deny-all policy to the backend namespace:
+
[source,bash,role=execute]
----
cat << 'EOF' | oc apply -f -
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: deny-all
spec:
  podSelector: {}
EOF
----
+
Expected output:
+
----
networkpolicy.networking.k8s.io/deny-all created
----

. Create a namespace for the frontend team:
+
[source,bash,role=execute]
----
oc new-project frontend-team
----

. Deploy a frontend application:
+
[source,bash,role=execute]
----
oc new-app --name frontend-app --image quay.io/redhattraining/hello-world-nginx:v1.0
----

. Wait for the frontend pod to be ready:
+
[source,bash,role=execute]
----
oc rollout status deployment/frontend-app --timeout=60s
----

=== Verify cross-namespace traffic is blocked

. From the frontend namespace, try to reach the backend API. First, get the backend service IP:
+
[source,bash,role=execute]
----
BACKEND_SVC_IP=$(oc get svc backend-api -n backend-team -o jsonpath='{.spec.clusterIP}')
echo "Backend service IP: $BACKEND_SVC_IP"
----

. Try to access the backend from the frontend pod:
+
[source,bash,role=execute]
----
BACKEND_SVC_IP=$(oc get svc backend-api -n backend-team -o jsonpath='{.spec.clusterIP}')
oc exec deploy/frontend-app -n frontend-team -- curl -s --connect-timeout 5 $BACKEND_SVC_IP:8080
----
+
This should time out. The deny-all policy in the backend namespace blocks all ingress traffic, including cross-namespace traffic.

=== Create a cross-namespace allow policy

To allow the frontend team's pods to reach the backend, you need a policy in the backend namespace that uses a `namespaceSelector`. First, label the frontend namespace so the policy can reference it.

. Label the frontend-team namespace:
+
[source,bash,role=execute]
----
oc label namespace frontend-team team=frontend
----
+
Expected output:
+
----
namespace/frontend-team labeled
----

. Create a network policy in the backend namespace that allows traffic from the frontend namespace:
+
[source,bash,role=execute]
----
cat << 'EOF' | oc apply -n backend-team -f -
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: allow-from-frontend
spec:
  podSelector:
    matchLabels:
      deployment: backend-api
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          team: frontend
    ports:
    - port: 8080
      protocol: TCP
EOF
----
+
Expected output:
+
----
networkpolicy.networking.k8s.io/allow-from-frontend created
----

. Test the cross-namespace connection again:
+
[source,bash,role=execute]
----
BACKEND_SVC_IP=$(oc get svc backend-api -n backend-team -o jsonpath='{.spec.clusterIP}')
oc exec deploy/frontend-app -n frontend-team -- curl -s $BACKEND_SVC_IP:8080 | grep Hello
----
+
Expected output:
+
----
<h1>Hello, world from nginx!</h1>
----

=== Verify namespace isolation

Confirm that only the frontend namespace has access. Pods from the original test namespace should still be blocked.

. Test from the network-policy-test namespace:
+
[source,bash,role=execute]
----
BACKEND_SVC_IP=$(oc get svc backend-api -n backend-team -o jsonpath='{.spec.clusterIP}')
oc exec deploy/test -n network-policy-test -- curl -s --connect-timeout 5 $BACKEND_SVC_IP:8080
----
+
This should time out. Only the frontend-team namespace is allowed.

. Review the policies in the backend namespace:
+
[source,bash,role=execute]
----
oc get networkpolicies -n backend-team
----
+
Expected output:
+
----
NAME                   POD-SELECTOR           AGE
allow-from-frontend    deployment=backend-api 2m
deny-all               <none>                 5m
----

=== Verify

[source,bash,role=execute]
----
echo "=== Test 1: frontend -> backend (should succeed) ==="
BACKEND_SVC_IP=$(oc get svc backend-api -n backend-team -o jsonpath='{.spec.clusterIP}')
oc exec deploy/frontend-app -n frontend-team -- curl -s --connect-timeout 5 $BACKEND_SVC_IP:8080 | grep Hello

echo "=== Test 2: network-policy-test -> backend (should fail) ==="
oc exec deploy/test -n network-policy-test -- curl -s --connect-timeout 5 $BACKEND_SVC_IP:8080 || echo "Blocked as expected"
----

Verification checklist:

* Frontend team can reach the backend API on port 8080
* Other namespaces cannot reach the backend API
* The deny-all baseline remains active in the backend namespace
* Namespace labels are used to identify allowed source namespaces

image::cross-namespace-policy.png[Cross-namespace network policy allowing frontend to backend,link=self,window=blank,width=700,title="Cross-Namespace Network Policy"]

You've implemented ACME's multi-team network isolation requirement.

[#exercise-2-troubleshoot-network-policy-issues]
== Exercise 2: Troubleshoot network policy issues

ACME's teams will inevitably encounter connectivity issues as network policies are rolled out. You need a repeatable troubleshooting methodology that any team member can follow.

=== The troubleshooting methodology

When a pod cannot connect to a destination, follow these steps in order:

. **Identify the source and destination pods** and their labels
. **List all network policies** that affect the source (egress) and destination (ingress)
. **Check pod selectors** to confirm which policies apply to which pods
. **Verify namespace labels** for cross-namespace rules
. **Test connectivity** incrementally after each change

=== Scenario: Diagnose a blocked connection

A developer reports that a new `reporting` pod in the frontend namespace cannot reach the backend API. Walk through the troubleshooting steps.

. Create the reporting deployment in the frontend namespace:
+
[source,bash,role=execute]
----
oc run reporting --image quay.io/redhattraining/hello-world-nginx:v1.0 -n frontend-team
----

. Wait for the pod to be ready:
+
[source,bash,role=execute]
----
oc wait pod/reporting -n frontend-team --for=condition=Ready --timeout=60s
----

. Confirm the connection fails:
+
[source,bash,role=execute]
----
BACKEND_SVC_IP=$(oc get svc backend-api -n backend-team -o jsonpath='{.spec.clusterIP}')
oc exec reporting -n frontend-team -- curl -s --connect-timeout 5 $BACKEND_SVC_IP:8080
----
+
This times out. But the frontend namespace is allowed to reach the backend, so why is it blocked?

=== Step 1: Identify pod labels

. Check the labels on the reporting pod:
+
[source,bash,role=execute]
----
oc get pod reporting -n frontend-team --show-labels
----
+
Notice the label: `run=reporting`. Compare this with the frontend-app pod:
+
[source,bash,role=execute]
----
oc get pods -n frontend-team --show-labels
----
+
The `frontend-app` pod has `deployment=frontend-app`, while the `reporting` pod has `run=reporting`.

=== Step 2: Check the network policies

. Examine the allow-from-frontend policy in the backend namespace:
+
[source,bash,role=execute]
----
oc describe networkpolicy allow-from-frontend -n backend-team
----
+
The policy allows traffic from pods in namespaces labeled `team=frontend`. It does not filter on specific pod labels within that namespace, so the namespace label should be sufficient.

. Check the ingress policies more carefully. The `allow-from-frontend` policy uses a `namespaceSelector` without a `podSelector` under the `from` block, which means all pods in the frontend-team namespace should be allowed.

=== Step 3: Check for egress restrictions

. Check if there are any network policies in the frontend-team namespace:
+
[source,bash,role=execute]
----
oc get networkpolicies -n frontend-team
----
+
If no egress policies exist in the frontend namespace, the issue is elsewhere. If the output shows `No resources found`, egress is unrestricted.

. The `allow-from-frontend` policy uses a `namespaceSelector`, so let's verify the namespace label:
+
[source,bash,role=execute]
----
oc get namespace frontend-team --show-labels | grep team
----
+
Expected: The namespace should have the `team=frontend` label.

=== Step 4: Narrow down the issue

Since the namespace label is correct and the policy allows all pods from the frontend namespace, try a direct pod IP test to rule out DNS issues:

[source,bash,role=execute]
----
BACKEND_POD_IP=$(oc get pod -l deployment=backend-api -n backend-team -o jsonpath='{.items[0].status.podIP}')
echo "Backend pod IP: $BACKEND_POD_IP"
oc exec reporting -n frontend-team -- curl -s --connect-timeout 5 $BACKEND_POD_IP:8080 | grep Hello
----

If this succeeds, the issue was DNS-related. If it still fails, there may be an additional policy or the namespace label is missing.

=== Step 5: Apply the fix

If the reporting pod was blocked, it could be due to a missing namespace label or a more restrictive policy. In our case, verify the policies are correct and the connection should work:

[source,bash,role=execute]
----
BACKEND_SVC_IP=$(oc get svc backend-api -n backend-team -o jsonpath='{.spec.clusterIP}')
oc exec reporting -n frontend-team -- curl -s --connect-timeout 5 $BACKEND_SVC_IP:8080 | grep Hello
----

If connectivity still fails, the troubleshooting methodology reveals the exact point of failure, which you can then address with a targeted policy change.

=== Useful diagnostic commands

Here is a reference of commands for troubleshooting network policies:

. **List all policies affecting a namespace**:
+
[source,bash,role=execute]
----
oc get networkpolicies -n backend-team -o wide
----

. **View policy details with selectors**:
+
[source,bash,role=execute]
----
oc describe networkpolicies -n backend-team
----

. **Check pod labels**:
+
[source,bash,role=execute]
----
oc get pods -n frontend-team --show-labels
----

. **Check namespace labels**:
+
[source,bash,role=execute]
----
oc get namespaces --show-labels
----

. **View policy YAML for detailed inspection**:
+
[source,bash,role=execute]
----
oc get networkpolicy allow-from-frontend -n backend-team -o yaml
----

=== Verify

Run a comprehensive check across all namespaces to confirm the expected connectivity:

[source,bash,role=execute]
----
BACKEND_SVC_IP=$(oc get svc backend-api -n backend-team -o jsonpath='{.spec.clusterIP}')

echo "=== frontend-app -> backend-api (should succeed) ==="
oc exec deploy/frontend-app -n frontend-team -- curl -s --connect-timeout 5 $BACKEND_SVC_IP:8080 | grep Hello

echo "=== reporting -> backend-api (should succeed) ==="
oc exec reporting -n frontend-team -- curl -s --connect-timeout 5 $BACKEND_SVC_IP:8080 | grep Hello

echo "=== test (network-policy-test) -> backend-api (should fail) ==="
oc exec deploy/test -n network-policy-test -- curl -s --connect-timeout 5 $BACKEND_SVC_IP:8080 || echo "Blocked as expected"

echo "=== test -> hello (network-policy-test, should succeed) ==="
oc exec deploy/test -n network-policy-test -- curl -s --connect-timeout 5 hello.network-policy-test:8080 | grep Hello
----

Verification checklist:

* All pods in the frontend-team namespace can reach backend-api
* Pods in other namespaces remain blocked from backend-api
* Module 1 and Module 2 policies in network-policy-test still function correctly
* You can systematically identify which policy is blocking or allowing traffic

image::troubleshooting-overview.png[Diagnostic output showing network policy troubleshooting,link=self,window=blank,width=700,title="Network Policy Troubleshooting"]

== Troubleshooting

**Issue**: Cross-namespace policy created but traffic still blocked

**Solution**:

. Verify the namespace label exists and matches the policy:
+
[source,bash]
----
oc get namespace frontend-team --show-labels
----

. If the label is missing, add it:
+
[source,bash]
----
oc label namespace frontend-team team=frontend
----

. Check that the policy is in the correct namespace (the destination namespace, not the source):
+
[source,bash]
----
oc get networkpolicies -n backend-team
----

**Issue**: Policy works for some pods but not others in the same namespace

**Solution**:

. Check if the policy uses a `podSelector` under `from` that restricts which source pods are allowed:
+
[source,bash]
----
oc describe networkpolicy allow-from-frontend -n backend-team
----

. If the `from` block combines `namespaceSelector` and `podSelector` in the same item, both must match. If they are separate items, either can match (OR logic).

**Issue**: Cannot determine which policy is blocking traffic

**Solution**:

. List all policies in both source and destination namespaces:
+
[source,bash]
----
oc get networkpolicies -n <source-namespace>
oc get networkpolicies -n <destination-namespace>
----

. Check for deny-all policies (empty `podSelector` with no ingress/egress rules).

. Remember: ingress policies are checked on the destination, egress policies on the source. Both must allow the traffic for it to succeed.

== Learning outcomes

By completing this module, you should now understand:

* How to use namespace labels and `namespaceSelector` to create cross-namespace network policies
* That network policies are applied in the destination namespace for ingress and the source namespace for egress
* A systematic troubleshooting methodology: identify pods, list policies, check selectors, verify labels, test incrementally
* How to use `oc describe`, `--show-labels`, and other diagnostic commands to debug connectivity issues
* That `namespaceSelector` and `podSelector` can be combined for fine-grained cross-namespace rules

== Module summary

You've completed the final module and can now present a comprehensive network security solution to ACME's leadership.

**What you accomplished for ACME:**

* Implemented cross-namespace policies allowing frontend-to-backend communication
* Used namespace labels for scalable, team-based access control
* Established a troubleshooting methodology that any team member can follow
* Validated connectivity across all three namespaces

**Business impact realized:**

* **Multi-team isolation**: Teams can share a cluster while maintaining network boundaries
* **Scalable policy management**: Namespace labels make policies easy to manage as teams grow
* **Reduced incident resolution time**: Structured troubleshooting methodology speeds up diagnosis
* **Operational readiness**: ACME's teams have the tools and knowledge to manage network policies independently

**Workshop complete:**

You've progressed from understanding default networking behavior through implementing comprehensive ingress, egress, and cross-namespace policies. ACME Corporation now has a proven network security approach ready for production deployment.
